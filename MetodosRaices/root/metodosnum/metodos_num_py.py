# -*- coding: utf-8 -*-
"""metodos_num.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gXCm8o_gUetFk0j-Aw3FHQixaB130NZL
"""

import numpy as np
from scipy.misc import derivative
f = lambda x: x
interv = ("1,1")
tol = 0.001
TOL = 0.001
n0 = 100
p0 = 0.1
max_iter = 100
x0 = 1
x1 = 1

def biseccion(f, interv, tol, n0):
      a, b = map(float, interv.split(','))
      i = 1
      while (i <= n0):
        p = a + (b - a)/2
        if (f(p) < tol):
          return p
          if (f(a)*f(b) > 0):
            a = p
          else:
            b = p
        i =+ 1

def iteracion(f, p0, n0):
  tol = 0.001
  i = 1
  b = f(p0)
  while(i <= n0):
    p0 = b
    b = f(p0)
    tramo = abs(b-p0)
    i +=  1
    respuesta = b


def newton(f, x0, TOL, max_iter):
    i = 1

    while i <= n0:
        xn = x0 - f(x0) / derivative(f,x0)

        if (abs(xn - x0) < TOL):
            print('La raíz aproximada es:', xn)
            return xn
        if (i == max_iter):
          print('El método falló después de ', i,' iteraciones')
        x0 = xn
        i += 1

def itera(f, p0, tol, n0):
    i = 0
    while (i <= n0):
      p = f(p0)
      if (abs(p - p0) < tol):
        return p
      i += 1
      p0 = p


def secante(f, x0, x1, tol, max_iter):
    i = 0
    while i < max_iter:
        x2 = x1 - f(x1) * ((x1 - x0) / (f(x1) - f(x0)))
        if abs(x2 - x1) < tol:
            return x2
        x0 = x1
        x1 = x2
        i += 1
    raise ValueError("El método no converge después de {} iteraciones.".format(max_iter))


def secante2(f, interv, tol, n0):
  a, b = map(float, interv.split(','))
  i=2
  if (f(a) > 0):
    p0 = b
    q0 = f(a)
    q1 = f(b)
  else:
    p0 = a
    q0 = f(b)
    q1 = f(a)
  while(i<=n0):
    if(f(a) > 0):
      p = p0 - (q1 / (q1 - q0)) * (p0 -a)
    else:
      p = p0 - (q1 / (q0 - q1)) * (b - p0)
    if (abs(p - p0) < tol):
      return p
    p0 = p
    q1 = f(p)
    i += 1
    return p
